<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Snake Clash Lite — Fake 3D</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#0b0f14; }
    canvas { display:block; }
    .hint {
      position: fixed; left: 12px; top: 10px; color: #cbd5e1;
      font: 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      opacity: 0.9; user-select: none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">Move mouse • Eat green • Defeat smaller snakes • Avoid bigger</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

const WORLD_W = 2600;
const WORLD_H = 2600;
const FOOD_COUNT = 240;
const AI_COUNT = 7;

// Fake-3D camera settings
const CAMERA_TILT = 0.72;         // 0..1, more = more "depth"
const MIN_SCALE = 0.55;           // farthest scale
const MAX_SCALE = 1.15;           // nearest scale
const HORIZON_PUSH = 140;         // pushes far objects upward

let mouse = { x: canvas.width/2, y: canvas.height/2 };
addEventListener("mousemove", e => (mouse.x = e.clientX, mouse.y = e.clientY));

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function dist(ax, ay, bx, by){ return Math.hypot(ax-bx, ay-by); }
function rand(a,b){ return a + Math.random()*(b-a); }

function shade(hex, amt){
  // quick hex shade helper: amt -40..40
  const c = hex.replace("#","").match(/.{2}/g).map(x=>parseInt(x,16));
  const t = c.map(v=>clamp(v+amt,0,255));
  return "#" + t.map(v=>v.toString(16).padStart(2,"0")).join("");
}

// Perspective: map world y into scale + screen y warp
function perspectiveFor(worldY){
  const t = clamp(worldY / WORLD_H, 0, 1);     // 0 top, 1 bottom
  const s = MIN_SCALE + (MAX_SCALE - MIN_SCALE) * Math.pow(t, 1.25);
  return s;
}

function worldToScreen(wx, wy, cam){
  const s = perspectiveFor(wy);

  // camera relative
  const rx = wx - cam.x;
  const ry = wy - cam.y;

  // apply tilt: compress vertical, push far up a bit
  const sx = canvas.width/2 + rx * s;
  const sy = canvas.height/2 + (ry * s * CAMERA_TILT) - (1 - s) * HORIZON_PUSH;

  return { x: sx, y: sy, s };
}

// Simple background: gradient + grid with perspective scaling
function drawGround(cam){
  // sky-to-ground gradient
  const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
  g.addColorStop(0, "#070a0f");
  g.addColorStop(0.55, "#0b1320");
  g.addColorStop(1, "#071018");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // grid lines in world space (coarse)
  ctx.save();
  ctx.globalAlpha = 0.28;

  const step = 160;
  // draw a reasonable range around camera
  const startX = Math.floor((cam.x - 1200)/step)*step;
  const endX   = Math.ceil((cam.x + 1200)/step)*step;
  const startY = Math.floor((cam.y - 1200)/step)*step;
  const endY   = Math.ceil((cam.y + 1200)/step)*step;

  // vertical lines
  for(let x = startX; x <= endX; x += step){
    // sample line as polyline across y to fake curvature/perspective
    ctx.beginPath();
    let first = true;
    for(let y = startY; y <= endY; y += 80){
      const p = worldToScreen(x, y, cam);
      if(first){ ctx.moveTo(p.x, p.y); first=false; }
      else ctx.lineTo(p.x, p.y);
    }
    ctx.strokeStyle = "#1c2a3a";
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // horizontal lines
  for(let y = startY; y <= endY; y += step){
    ctx.beginPath();
    let first = true;
    for(let x = startX; x <= endX; x += 80){
      const p = worldToScreen(x, y, cam);
      if(first){ ctx.moveTo(p.x, p.y); first=false; }
      else ctx.lineTo(p.x, p.y);
    }
    ctx.strokeStyle = "#152235";
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  ctx.restore();
}

class Food {
  constructor(){
    this.x = rand(0, WORLD_W);
    this.y = rand(0, WORLD_H);
    this.r = rand(5, 7);
  }
}

class Snake {
  constructor(x,y,color,isPlayer=false){
    this.x = x; this.y = y;
    this.vx = 0; this.vy = 0;
    this.baseR = 14;
    this.mass = 1;
    this.speed = 2.1;
    this.color = color;
    this.isPlayer = isPlayer;
    this.wander = rand(0,Math.PI*2);
  }
  get r(){ return this.baseR + this.mass*2.5; }

  update(){
    let ax=0, ay=0;

    if(this.isPlayer){
      // move toward mouse direction, camera centered on player
      const dx = mouse.x - canvas.width/2;
      const dy = mouse.y - canvas.height/2;
      const ang = Math.atan2(dy, dx);
      ax = Math.cos(ang);
      ay = Math.sin(ang);
    } else {
      // simple AI: wander + slight attraction to nearby food
      this.wander += rand(-0.10, 0.10);
      ax = Math.cos(this.wander);
      ay = Math.sin(this.wander);
    }

    const len = Math.hypot(ax,ay) || 1;
    ax/=len; ay/=len;

    const targetSpeed = this.speed * (1 + Math.min(0.8, this.mass*0.06));
    this.vx = this.vx*0.84 + ax*targetSpeed*0.16;
    this.vy = this.vy*0.84 + ay*targetSpeed*0.16;

    this.x += this.vx;
    this.y += this.vy;

    this.x = clamp(this.x, 0, WORLD_W);
    this.y = clamp(this.y, 0, WORLD_H);
  }
}

const player = new Snake(WORLD_W/2, WORLD_H/2, "#22d3ee", true);

const ai = [];
for(let i=0;i<AI_COUNT;i++){
  ai.push(new Snake(rand(100,WORLD_W-100), rand(100,WORLD_H-100),
    `#${Math.floor(rand(0,0xffffff)).toString(16).padStart(6,"0")}`));
}

let food = Array.from({length:FOOD_COUNT}, ()=>new Food());

function respawnFood(){
  while(food.length < FOOD_COUNT) food.push(new Food());
}

function eatFood(s){
  // Eat nearby food
  for(let i=food.length-1; i>=0; i--){
    if(dist(s.x,s.y,food[i].x,food[i].y) < s.r){
      s.mass += 0.18;
      food.splice(i,1);
    }
  }
}

function snakeCombat(){
  // Player vs AI only (simple)
  for(let i=ai.length-1; i>=0; i--){
    const s = ai[i];
    const d = dist(player.x,player.y,s.x,s.y);
    if(d < player.r + s.r*0.25){
      if(player.r > s.r + 2){
        player.mass += s.mass*0.55;
        ai.splice(i,1);
      } else if(s.r > player.r + 2){
        gameOver();
        return;
      }
    }
  }
  // keep AI count
  while(ai.length < AI_COUNT){
    ai.push(new Snake(rand(0,WORLD_W), rand(0,WORLD_H),
      `hsl(${rand(0,360)},70%,55%)`));
  }
}

let dead = false;
function gameOver(){
  if(dead) return;
  dead = true;
  setTimeout(()=>{
    alert("Game Over!");
    location.reload();
  }, 50);
}

// Fake-3D draw helpers
function drawShadow(p, radius){
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.beginPath();
  ctx.ellipse(p.x, p.y + radius*0.55, radius*1.05, radius*0.55, 0, 0, Math.PI*2);
  ctx.fillStyle = "#000";
  ctx.fill();
  ctx.restore();
}

function draw3DBall(p, radius, color){
  // stacked discs with slight highlights
  drawShadow(p, radius);

  // base
  ctx.beginPath();
  ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
  ctx.fillStyle = color;
  ctx.fill();

  // highlight
  ctx.beginPath();
  ctx.arc(p.x - radius*0.25, p.y - radius*0.28, radius*0.45, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.16)";
  ctx.fill();

  // rim shade
  ctx.beginPath();
  ctx.arc(p.x + radius*0.15, p.y + radius*0.18, radius*0.75, 0, Math.PI*2);
  ctx.fillStyle = "rgba(0,0,0,0.12)";
  ctx.fill();
}

function drawSnakeDisc(s, cam){
  const p = worldToScreen(s.x, s.y, cam);
  const radius = s.r * p.s;

  // darker when far to sell depth
  const depthTint = Math.floor((p.s - MIN_SCALE) / (MAX_SCALE - MIN_SCALE) * 24 - 14);
  const body = shade(s.color, depthTint);

  draw3DBall(p, radius, body);

  if(s.isPlayer){
    // tiny direction indicator (fake "head")
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.arc(p.x + radius*0.55, p.y - radius*0.10, Math.max(2, radius*0.12), 0, Math.PI*2);
    ctx.fillStyle = "#e2e8f0";
    ctx.fill();
    ctx.restore();
  }
}

function drawFood(f, cam){
  const p = worldToScreen(f.x, f.y, cam);
  const r = f.r * p.s;
  // glow
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.beginPath();
  ctx.arc(p.x, p.y, r*2.2, 0, Math.PI*2);
  ctx.fillStyle = "lime";
  ctx.fill();
  ctx.restore();

  draw3DBall(p, r, "#32cd32");
}

function drawHUD(){
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
  ctx.fillText(`Size: ${Math.floor(player.r)}   Enemies: ${ai.length}`, 14, canvas.height - 16);
  ctx.restore();
}

// Render order: sort by worldY so far objects draw first
function render(cam){
  drawGround(cam);

  const drawables = [];

  for(const f of food) drawables.push({ y:f.y, type:"food", obj:f });
  for(const s of ai)   drawables.push({ y:s.y, type:"snake", obj:s });
  drawables.push({ y:player.y, type:"snake", obj:player });

  drawables.sort((a,b)=>a.y-b.y);

  for(const d of drawables){
    if(d.type==="food") drawFood(d.obj, cam);
    else drawSnakeDisc(d.obj, cam);
  }

  drawHUD();
}

function update(){
  if(dead) return;

  player.update();
  for(const s of ai) s.update();

  eatFood(player);
  for(const s of ai) eatFood(s);

  respawnFood();
  snakeCombat();
}

// camera follows player
function loop(){
  update();
  render({ x: player.x, y: player.y });
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
