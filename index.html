<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Snake Clash â€“ Fake 3D</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#0b0f14;}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>

const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d");
function resize(){canvas.width=innerWidth;canvas.height=innerHeight;}
addEventListener("resize",resize);resize();

const WORLD_W=2600,WORLD_H=2600;
const FOOD_COUNT=250;
const AI_COUNT=6;

const CAMERA_TILT=0.72;
const MIN_SCALE=0.55;
const MAX_SCALE=1.15;
const HORIZON_PUSH=140;

let mouse={x:canvas.width/2,y:canvas.height/2};
addEventListener("mousemove",e=>{mouse.x=e.clientX;mouse.y=e.clientY;});

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function dist(ax,ay,bx,by){return Math.hypot(ax-bx,ay-by);}
function rand(a,b){return a+Math.random()*(b-a);}

function perspectiveFor(y){
const t=clamp(y/WORLD_H,0,1);
return MIN_SCALE+(MAX_SCALE-MIN_SCALE)*Math.pow(t,1.25);
}

function worldToScreen(wx,wy,cam){
const s=perspectiveFor(wy);
const rx=wx-cam.x;
const ry=wy-cam.y;
return{
x:canvas.width/2+rx*s,
y:canvas.height/2+(ry*s*CAMERA_TILT)-(1-s)*HORIZON_PUSH,
s
};
}

class Food{
constructor(){
this.x=rand(0,WORLD_W);
this.y=rand(0,WORLD_H);
this.r=rand(5,7);
}
}

class Snake{
constructor(x,y,color,isPlayer=false,segments=null){
this.isPlayer=isPlayer;
this.color=color;
this.x=x;this.y=y;
this.vx=0;this.vy=0;
this.speed=2.4;
this.wander=rand(0,Math.PI*2);
this.segRadius=11;
this.spacing=7.5;

if(segments){
this.segments=segments.map(p=>({x:p.x,y:p.y}));
this.targetSegments=this.segments.length;
this.x=this.segments[0].x;
this.y=this.segments[0].y;
}else{
this.targetSegments=26;
this.segments=[];
for(let i=0;i<this.targetSegments;i++){
this.segments.push({x:x-i*this.spacing,y});
}
}
}

get length(){return this.targetSegments;}

grow(n){
this.targetSegments+=n;
this.targetSegments=Math.min(this.targetSegments,260);
}

update(){
let ax=0,ay=0;

if(this.isPlayer){
const dx=mouse.x-canvas.width/2;
const dy=mouse.y-canvas.height/2;
const ang=Math.atan2(dy,dx);
ax=Math.cos(ang);ay=Math.sin(ang);
}else{
this.wander+=rand(-0.1,0.1);
ax=Math.cos(this.wander);
ay=Math.sin(this.wander);
}

const len=Math.hypot(ax,ay)||1;
ax/=len;ay/=len;

const speedFactor=1-Math.min(0.35,(this.targetSegments-26)*0.0015);
const targetSpeed=this.speed*speedFactor;

this.vx=this.vx*0.84+ax*targetSpeed*0.16;
this.vy=this.vy*0.84+ay*targetSpeed*0.16;

this.x+=this.vx;
this.y+=this.vy;
this.x=clamp(this.x,0,WORLD_W);
this.y=clamp(this.y,0,WORLD_H);

this.segments[0].x=this.x;
this.segments[0].y=this.y;

for(let i=1;i<this.segments.length;i++){
const prev=this.segments[i-1];
const cur=this.segments[i];
const dx=cur.x-prev.x;
const dy=cur.y-prev.y;
const d=Math.hypot(dx,dy)||0.0001;
const pull=(d-this.spacing)/d;
cur.x-=dx*pull;
cur.y-=dy*pull;
}

while(this.segments.length<this.targetSegments){
const last=this.segments[this.segments.length-1];
this.segments.push({x:last.x,y:last.y});
}
if(this.segments.length>this.targetSegments){
this.segments.length=this.targetSegments;
}
}
}

const player=new Snake(WORLD_W/2,WORLD_H/2,"#22d3ee",true);

let ai=[];
for(let i=0;i<AI_COUNT;i++){
ai.push(new Snake(rand(100,WORLD_W-100),rand(100,WORLD_H-100),`hsl(${rand(0,360)},70%,55%)`));
}

let food=Array.from({length:FOOD_COUNT},()=>new Food());
function respawnFood(){while(food.length<FOOD_COUNT)food.push(new Food());}

function eatFood(s){
for(let i=food.length-1;i>=0;i--){
if(dist(s.x,s.y,food[i].x,food[i].y)<s.segRadius+6){
s.grow(3);
food.splice(i,1);
}
}
}

function bisectSnake(enemy,hitIndex){
const left=enemy.segments.slice(0,hitIndex);
const right=enemy.segments.slice(hitIndex+1);
const parts=[];
const MIN=10;

if(left.length>=MIN){
parts.push(new Snake(left[0].x,left[0].y,enemy.color,false,left));
}else{
left.forEach(p=>food.push(new Food()));
}

if(right.length>=MIN){
parts.push(new Snake(right[0].x,right[0].y,enemy.color,false,right));
}else{
right.forEach(p=>food.push(new Food()));
}

return parts;
}

function snakeCombat(){
for(let i=ai.length-1;i>=0;i--){
const enemy=ai[i];
let hitIndex=-1;

for(let s=1;s<enemy.segments.length;s++){
if(dist(player.x,player.y,enemy.segments[s].x,enemy.segments[s].y)
<player.segRadius+enemy.segRadius){
hitIndex=s;
break;
}
}

if(hitIndex===-1)continue;

if(enemy.length>player.length){
alert("Game Over!");
location.reload();
return;
}

const margin=8;
const isMiddle=hitIndex>=margin && hitIndex<=enemy.segments.length-margin;

if(isMiddle){
const newSnakes=bisectSnake(enemy,hitIndex);
ai.splice(i,1);
ai.push(...newSnakes);
player.grow(10);
}else{
player.grow(Math.floor(enemy.length*0.35));
ai.splice(i,1);
}
}

while(ai.length<AI_COUNT){
ai.push(new Snake(rand(0,WORLD_W),rand(0,WORLD_H),`hsl(${rand(0,360)},70%,55%)`));
}
}

function drawBall(p,r,color){
ctx.beginPath();
ctx.arc(p.x,p.y,r,0,Math.PI*2);
ctx.fillStyle=color;
ctx.fill();
}

function drawSnake(s,cam){
for(let i=s.segments.length-1;i>=0;i--){
const seg=s.segments[i];
const p=worldToScreen(seg.x,seg.y,cam);
const r=s.segRadius*p.s*(0.75+0.25*(1-i/s.segments.length));
drawBall(p,r,s.color);
}
}

function drawFood(f,cam){
const p=worldToScreen(f.x,f.y,cam);
drawBall(p,f.r*p.s,"lime");
}

function update(){
player.update();
ai.forEach(a=>a.update());
eatFood(player);
ai.forEach(a=>eatFood(a));
respawnFood();
snakeCombat();
}

function render(){
ctx.clearRect(0,0,canvas.width,canvas.height);
food.forEach(f=>drawFood(f,{x:player.x,y:player.y}));
ai.forEach(a=>drawSnake(a,{x:player.x,y:player.y}));
drawSnake(player,{x:player.x,y:player.y});
}

function loop(){
update();
render();
requestAnimationFrame(loop);
}
loop();

</script>
</body>
</html>
